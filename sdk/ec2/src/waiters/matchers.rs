// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// Matcher union: {"output":{"path":"BundleTasks[].State","expected":"complete","comparator":"allStringEquals"}}
pub(crate) fn match_describe_bundle_tasks_ab301da50ed1fbce6(
    _result: ::std::result::Result<
        &crate::operation::describe_bundle_tasks::DescribeBundleTasksOutput,
        &crate::operation::describe_bundle_tasks::DescribeBundleTasksError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_bundle_tasks::DescribeBundleTasksOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::BundleTaskState>> {
        let _fld_1 = _output.bundle_tasks.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::BundleTask) -> ::std::option::Option<&crate::types::BundleTaskState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "complete";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"BundleTasks[].State","expected":"failed","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_bundle_tasks_7d073988185526d00(
    _result: ::std::result::Result<
        &crate::operation::describe_bundle_tasks::DescribeBundleTasksOutput,
        &crate::operation::describe_bundle_tasks::DescribeBundleTasksError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_bundle_tasks::DescribeBundleTasksOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::BundleTaskState>> {
        let _fld_1 = _output.bundle_tasks.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::BundleTask) -> ::std::option::Option<&crate::types::BundleTaskState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "failed";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"ConversionTasks[].State","expected":"cancelled","comparator":"allStringEquals"}}
pub(crate) fn match_describe_conversion_tasks_2eac53a9d845cd968(
    _result: ::std::result::Result<
        &crate::operation::describe_conversion_tasks::DescribeConversionTasksOutput,
        &crate::operation::describe_conversion_tasks::DescribeConversionTasksError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_conversion_tasks::DescribeConversionTasksOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::ConversionTaskState>> {
        let _fld_1 = _output.conversion_tasks.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::ConversionTask) -> ::std::option::Option<&crate::types::ConversionTaskState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "cancelled";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"ConversionTasks[].State","expected":"completed","comparator":"allStringEquals"}}
pub(crate) fn match_describe_conversion_tasks_a04d0b6b1e0e5aa12(
    _result: ::std::result::Result<
        &crate::operation::describe_conversion_tasks::DescribeConversionTasksOutput,
        &crate::operation::describe_conversion_tasks::DescribeConversionTasksError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_conversion_tasks::DescribeConversionTasksOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::ConversionTaskState>> {
        let _fld_1 = _output.conversion_tasks.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::ConversionTask) -> ::std::option::Option<&crate::types::ConversionTaskState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "completed";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"ConversionTasks[].State","expected":"cancelled","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_conversion_tasks_a0cb52862cae2f257(
    _result: ::std::result::Result<
        &crate::operation::describe_conversion_tasks::DescribeConversionTasksOutput,
        &crate::operation::describe_conversion_tasks::DescribeConversionTasksError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_conversion_tasks::DescribeConversionTasksOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::ConversionTaskState>> {
        let _fld_1 = _output.conversion_tasks.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::ConversionTask) -> ::std::option::Option<&crate::types::ConversionTaskState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "cancelled";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"ConversionTasks[].State","expected":"cancelling","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_conversion_tasks_916d8711c370d993a(
    _result: ::std::result::Result<
        &crate::operation::describe_conversion_tasks::DescribeConversionTasksOutput,
        &crate::operation::describe_conversion_tasks::DescribeConversionTasksError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_conversion_tasks::DescribeConversionTasksOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::ConversionTaskState>> {
        let _fld_1 = _output.conversion_tasks.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::ConversionTask) -> ::std::option::Option<&crate::types::ConversionTaskState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "cancelling";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"ConversionTasks[].State","expected":"deleted","comparator":"allStringEquals"}}
pub(crate) fn match_describe_conversion_tasks_56e8bb568132d8b17(
    _result: ::std::result::Result<
        &crate::operation::describe_conversion_tasks::DescribeConversionTasksOutput,
        &crate::operation::describe_conversion_tasks::DescribeConversionTasksError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_conversion_tasks::DescribeConversionTasksOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::ConversionTaskState>> {
        let _fld_1 = _output.conversion_tasks.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::ConversionTask) -> ::std::option::Option<&crate::types::ConversionTaskState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "deleted";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"CustomerGateways[].State","expected":"available","comparator":"allStringEquals"}}
pub(crate) fn match_describe_customer_gateways_6da987821df1a37ea(
    _result: ::std::result::Result<
        &crate::operation::describe_customer_gateways::DescribeCustomerGatewaysOutput,
        &crate::operation::describe_customer_gateways::DescribeCustomerGatewaysError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_customer_gateways::DescribeCustomerGatewaysOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.customer_gateways.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::CustomerGateway) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "available";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"CustomerGateways[].State","expected":"deleted","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_customer_gateways_9229a1e6757cb96ef(
    _result: ::std::result::Result<
        &crate::operation::describe_customer_gateways::DescribeCustomerGatewaysOutput,
        &crate::operation::describe_customer_gateways::DescribeCustomerGatewaysError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_customer_gateways::DescribeCustomerGatewaysOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.customer_gateways.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::CustomerGateway) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "deleted";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"CustomerGateways[].State","expected":"deleting","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_customer_gateways_3a2b89947afd15ad8(
    _result: ::std::result::Result<
        &crate::operation::describe_customer_gateways::DescribeCustomerGatewaysOutput,
        &crate::operation::describe_customer_gateways::DescribeCustomerGatewaysError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_customer_gateways::DescribeCustomerGatewaysOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.customer_gateways.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::CustomerGateway) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "deleting";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"ExportTasks[].State","expected":"cancelled","comparator":"allStringEquals"}}
pub(crate) fn match_describe_export_tasks_41e11dd6f30c1b624(
    _result: ::std::result::Result<
        &crate::operation::describe_export_tasks::DescribeExportTasksOutput,
        &crate::operation::describe_export_tasks::DescribeExportTasksError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_export_tasks::DescribeExportTasksOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::ExportTaskState>> {
        let _fld_1 = _output.export_tasks.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::ExportTask) -> ::std::option::Option<&crate::types::ExportTaskState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "cancelled";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"ExportTasks[].State","expected":"completed","comparator":"allStringEquals"}}
pub(crate) fn match_describe_export_tasks_3884d0b74d02d2b16(
    _result: ::std::result::Result<
        &crate::operation::describe_export_tasks::DescribeExportTasksOutput,
        &crate::operation::describe_export_tasks::DescribeExportTasksError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_export_tasks::DescribeExportTasksOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::ExportTaskState>> {
        let _fld_1 = _output.export_tasks.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::ExportTask) -> ::std::option::Option<&crate::types::ExportTaskState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "completed";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"Images[].State","expected":"available","comparator":"allStringEquals"}}
pub(crate) fn match_describe_images_3acc318c83d8a4452(
    _result: ::std::result::Result<&crate::operation::describe_images::DescribeImagesOutput, &crate::operation::describe_images::DescribeImagesError>,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_images::DescribeImagesOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::ImageState>> {
        let _fld_1 = _output.images.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::Image) -> ::std::option::Option<&crate::types::ImageState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "available";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"Images[].State","expected":"failed","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_images_059a66e170d3df7a5(
    _result: ::std::result::Result<&crate::operation::describe_images::DescribeImagesOutput, &crate::operation::describe_images::DescribeImagesError>,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_images::DescribeImagesOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::ImageState>> {
        let _fld_1 = _output.images.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::Image) -> ::std::option::Option<&crate::types::ImageState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "failed";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"length(Images[]) > `0`","expected":"true","comparator":"booleanEquals"}}
pub(crate) fn match_describe_images_dce6e4d979f63dcae(
    _result: ::std::result::Result<&crate::operation::describe_images::DescribeImagesOutput, &crate::operation::describe_images::DescribeImagesError>,
) -> bool {
    fn path_traversal<'a>(_output: &'a crate::operation::describe_images::DescribeImagesOutput) -> ::std::option::Option<bool> {
        let _fld_2 = _output.images.as_ref()?;
        let _ret_1 = _fld_2.len() as i64;
        const _LIT_3: &f64 = &0.0;
        let _tmp_5 = *_LIT_3;
        let _tmp_6 = _tmp_5 as i64;
        let _cmp_4 = _ret_1 > _tmp_6;
        ::std::option::Option::Some(_cmp_4)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            let right = true;
            let _cmp_1 = value == right;
            _cmp_1
        })
        .unwrap_or_default()
}

/// Matcher union: {"errorType":"InvalidAMIID.NotFound"}
pub(crate) fn match_describe_images_da0ba75c4a3b70507(
    _result: ::std::result::Result<&crate::operation::describe_images::DescribeImagesOutput, &crate::operation::describe_images::DescribeImagesError>,
) -> bool {
    if let ::std::result::Result::Err(err) = _result {
        if let ::std::option::Option::Some(code) = ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(err) {
            return code == "InvalidAMIID.NotFound";
        }
    }
    false
}

/// Matcher union: {"output":{"path":"ImageUsageReports[].State","expected":"available","comparator":"allStringEquals"}}
pub(crate) fn match_describe_image_usage_reports_aed9ba9e6d7822b30(
    _result: ::std::result::Result<
        &crate::operation::describe_image_usage_reports::DescribeImageUsageReportsOutput,
        &crate::operation::describe_image_usage_reports::DescribeImageUsageReportsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_image_usage_reports::DescribeImageUsageReportsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.image_usage_reports.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::ImageUsageReport) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "available";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"ImageUsageReports[].State","expected":"failed","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_image_usage_reports_9bae9b0fa5ea9f50d(
    _result: ::std::result::Result<
        &crate::operation::describe_image_usage_reports::DescribeImageUsageReportsOutput,
        &crate::operation::describe_image_usage_reports::DescribeImageUsageReportsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_image_usage_reports::DescribeImageUsageReportsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.image_usage_reports.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::ImageUsageReport) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "failed";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"length(Reservations[]) > `0`","expected":"true","comparator":"booleanEquals"}}
pub(crate) fn match_describe_instances_1c820128f4b43851a(
    _result: ::std::result::Result<
        &crate::operation::describe_instances::DescribeInstancesOutput,
        &crate::operation::describe_instances::DescribeInstancesError,
    >,
) -> bool {
    fn path_traversal<'a>(_output: &'a crate::operation::describe_instances::DescribeInstancesOutput) -> ::std::option::Option<bool> {
        let _fld_2 = _output.reservations.as_ref()?;
        let _ret_1 = _fld_2.len() as i64;
        const _LIT_3: &f64 = &0.0;
        let _tmp_5 = *_LIT_3;
        let _tmp_6 = _tmp_5 as i64;
        let _cmp_4 = _ret_1 > _tmp_6;
        ::std::option::Option::Some(_cmp_4)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            let right = true;
            let _cmp_1 = value == right;
            _cmp_1
        })
        .unwrap_or_default()
}

/// Matcher union: {"errorType":"InvalidInstanceID.NotFound"}
pub(crate) fn match_describe_instances_c46b5661fd6e97d44(
    _result: ::std::result::Result<
        &crate::operation::describe_instances::DescribeInstancesOutput,
        &crate::operation::describe_instances::DescribeInstancesError,
    >,
) -> bool {
    if let ::std::result::Result::Err(err) = _result {
        if let ::std::option::Option::Some(code) = ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(err) {
            return code == "InvalidInstanceID.NotFound";
        }
    }
    false
}

/// Matcher union: {"output":{"path":"Reservations[].Instances[].State.Name","expected":"running","comparator":"allStringEquals"}}
pub(crate) fn match_describe_instances_c4a29c5d7257153b8(
    _result: ::std::result::Result<
        &crate::operation::describe_instances::DescribeInstancesOutput,
        &crate::operation::describe_instances::DescribeInstancesError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_instances::DescribeInstancesOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::InstanceStateName>> {
        let _fld_1 = _output.reservations.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::Reservation) -> ::std::option::Option<&::std::vec::Vec<crate::types::Instance>> {
                    let _fld_2 = _v.instances.as_ref();
                    _fld_2
                }
                map(v)
            })
            .flatten()
            .collect::<::std::vec::Vec<_>>();
        let _prj_6 = _prj_3
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::Instance) -> ::std::option::Option<&crate::types::InstanceStateName> {
                    let _fld_4 = _v.state.as_ref();
                    let _fld_5 = _fld_4.and_then(|v| v.name.as_ref());
                    _fld_5
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_6)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "running";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"Reservations[].Instances[].State.Name","expected":"shutting-down","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_instances_fc32350815043b6a6(
    _result: ::std::result::Result<
        &crate::operation::describe_instances::DescribeInstancesOutput,
        &crate::operation::describe_instances::DescribeInstancesError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_instances::DescribeInstancesOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::InstanceStateName>> {
        let _fld_1 = _output.reservations.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::Reservation) -> ::std::option::Option<&::std::vec::Vec<crate::types::Instance>> {
                    let _fld_2 = _v.instances.as_ref();
                    _fld_2
                }
                map(v)
            })
            .flatten()
            .collect::<::std::vec::Vec<_>>();
        let _prj_6 = _prj_3
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::Instance) -> ::std::option::Option<&crate::types::InstanceStateName> {
                    let _fld_4 = _v.state.as_ref();
                    let _fld_5 = _fld_4.and_then(|v| v.name.as_ref());
                    _fld_5
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_6)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "shutting-down";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"Reservations[].Instances[].State.Name","expected":"terminated","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_instances_47f807e3deea95c88(
    _result: ::std::result::Result<
        &crate::operation::describe_instances::DescribeInstancesOutput,
        &crate::operation::describe_instances::DescribeInstancesError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_instances::DescribeInstancesOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::InstanceStateName>> {
        let _fld_1 = _output.reservations.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::Reservation) -> ::std::option::Option<&::std::vec::Vec<crate::types::Instance>> {
                    let _fld_2 = _v.instances.as_ref();
                    _fld_2
                }
                map(v)
            })
            .flatten()
            .collect::<::std::vec::Vec<_>>();
        let _prj_6 = _prj_3
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::Instance) -> ::std::option::Option<&crate::types::InstanceStateName> {
                    let _fld_4 = _v.state.as_ref();
                    let _fld_5 = _fld_4.and_then(|v| v.name.as_ref());
                    _fld_5
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_6)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "terminated";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"Reservations[].Instances[].State.Name","expected":"stopping","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_instances_5a7237d16cf0a4b1f(
    _result: ::std::result::Result<
        &crate::operation::describe_instances::DescribeInstancesOutput,
        &crate::operation::describe_instances::DescribeInstancesError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_instances::DescribeInstancesOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::InstanceStateName>> {
        let _fld_1 = _output.reservations.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::Reservation) -> ::std::option::Option<&::std::vec::Vec<crate::types::Instance>> {
                    let _fld_2 = _v.instances.as_ref();
                    _fld_2
                }
                map(v)
            })
            .flatten()
            .collect::<::std::vec::Vec<_>>();
        let _prj_6 = _prj_3
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::Instance) -> ::std::option::Option<&crate::types::InstanceStateName> {
                    let _fld_4 = _v.state.as_ref();
                    let _fld_5 = _fld_4.and_then(|v| v.name.as_ref());
                    _fld_5
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_6)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "stopping";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"InstanceStatuses[].InstanceStatus.Status","expected":"ok","comparator":"allStringEquals"}}
pub(crate) fn match_describe_instance_status_18d8df0a3dbc1c894(
    _result: ::std::result::Result<
        &crate::operation::describe_instance_status::DescribeInstanceStatusOutput,
        &crate::operation::describe_instance_status::DescribeInstanceStatusError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_instance_status::DescribeInstanceStatusOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::SummaryStatus>> {
        let _fld_1 = _output.instance_statuses.as_ref()?;
        let _prj_4 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::InstanceStatus) -> ::std::option::Option<&crate::types::SummaryStatus> {
                    let _fld_2 = _v.instance_status.as_ref();
                    let _fld_3 = _fld_2.and_then(|v| v.status.as_ref());
                    _fld_3
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_4)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "ok";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"errorType":"InvalidInstanceID.NotFound"}
pub(crate) fn match_describe_instance_status_c46b5661fd6e97d44(
    _result: ::std::result::Result<
        &crate::operation::describe_instance_status::DescribeInstanceStatusOutput,
        &crate::operation::describe_instance_status::DescribeInstanceStatusError,
    >,
) -> bool {
    if let ::std::result::Result::Err(err) = _result {
        if let ::std::option::Option::Some(code) = ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(err) {
            return code == "InvalidInstanceID.NotFound";
        }
    }
    false
}

/// Matcher union: {"output":{"path":"Reservations[].Instances[].State.Name","expected":"stopped","comparator":"allStringEquals"}}
pub(crate) fn match_describe_instances_b62d6681a104ef426(
    _result: ::std::result::Result<
        &crate::operation::describe_instances::DescribeInstancesOutput,
        &crate::operation::describe_instances::DescribeInstancesError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_instances::DescribeInstancesOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::InstanceStateName>> {
        let _fld_1 = _output.reservations.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::Reservation) -> ::std::option::Option<&::std::vec::Vec<crate::types::Instance>> {
                    let _fld_2 = _v.instances.as_ref();
                    _fld_2
                }
                map(v)
            })
            .flatten()
            .collect::<::std::vec::Vec<_>>();
        let _prj_6 = _prj_3
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::Instance) -> ::std::option::Option<&crate::types::InstanceStateName> {
                    let _fld_4 = _v.state.as_ref();
                    let _fld_5 = _fld_4.and_then(|v| v.name.as_ref());
                    _fld_5
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_6)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "stopped";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"Reservations[].Instances[].State.Name","expected":"pending","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_instances_8ad0c8f11617c2bd6(
    _result: ::std::result::Result<
        &crate::operation::describe_instances::DescribeInstancesOutput,
        &crate::operation::describe_instances::DescribeInstancesError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_instances::DescribeInstancesOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::InstanceStateName>> {
        let _fld_1 = _output.reservations.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::Reservation) -> ::std::option::Option<&::std::vec::Vec<crate::types::Instance>> {
                    let _fld_2 = _v.instances.as_ref();
                    _fld_2
                }
                map(v)
            })
            .flatten()
            .collect::<::std::vec::Vec<_>>();
        let _prj_6 = _prj_3
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::Instance) -> ::std::option::Option<&crate::types::InstanceStateName> {
                    let _fld_4 = _v.state.as_ref();
                    let _fld_5 = _fld_4.and_then(|v| v.name.as_ref());
                    _fld_5
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_6)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "pending";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"Reservations[].Instances[].State.Name","expected":"terminated","comparator":"allStringEquals"}}
pub(crate) fn match_describe_instances_68add750ed2efbe82(
    _result: ::std::result::Result<
        &crate::operation::describe_instances::DescribeInstancesOutput,
        &crate::operation::describe_instances::DescribeInstancesError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_instances::DescribeInstancesOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::InstanceStateName>> {
        let _fld_1 = _output.reservations.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::Reservation) -> ::std::option::Option<&::std::vec::Vec<crate::types::Instance>> {
                    let _fld_2 = _v.instances.as_ref();
                    _fld_2
                }
                map(v)
            })
            .flatten()
            .collect::<::std::vec::Vec<_>>();
        let _prj_6 = _prj_3
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::Instance) -> ::std::option::Option<&crate::types::InstanceStateName> {
                    let _fld_4 = _v.state.as_ref();
                    let _fld_5 = _fld_4.and_then(|v| v.name.as_ref());
                    _fld_5
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_6)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "terminated";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"length(InternetGateways[].InternetGatewayId) > `0`","expected":"true","comparator":"booleanEquals"}}
pub(crate) fn match_describe_internet_gateways_87ee24c169b4061c3(
    _result: ::std::result::Result<
        &crate::operation::describe_internet_gateways::DescribeInternetGatewaysOutput,
        &crate::operation::describe_internet_gateways::DescribeInternetGatewaysError,
    >,
) -> bool {
    fn path_traversal<'a>(_output: &'a crate::operation::describe_internet_gateways::DescribeInternetGatewaysOutput) -> ::std::option::Option<bool> {
        let _fld_2 = _output.internet_gateways.as_ref()?;
        let _prj_4 = _fld_2
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::InternetGateway) -> ::std::option::Option<&::std::string::String> {
                    let _fld_3 = _v.internet_gateway_id.as_ref();
                    _fld_3
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        let _ret_1 = _prj_4.len() as i64;
        const _LIT_5: &f64 = &0.0;
        let _tmp_7 = *_LIT_5;
        let _tmp_8 = _tmp_7 as i64;
        let _cmp_6 = _ret_1 > _tmp_8;
        ::std::option::Option::Some(_cmp_6)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            let right = true;
            let _cmp_1 = value == right;
            _cmp_1
        })
        .unwrap_or_default()
}

/// Matcher union: {"errorType":"InvalidInternetGateway.NotFound"}
pub(crate) fn match_describe_internet_gateways_23a231f190ff00c20(
    _result: ::std::result::Result<
        &crate::operation::describe_internet_gateways::DescribeInternetGatewaysOutput,
        &crate::operation::describe_internet_gateways::DescribeInternetGatewaysError,
    >,
) -> bool {
    if let ::std::result::Result::Err(err) = _result {
        if let ::std::option::Option::Some(code) = ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(err) {
            return code == "InvalidInternetGateway.NotFound";
        }
    }
    false
}

/// Matcher union: {"output":{"path":"length(KeyPairs[].KeyName) > `0`","expected":"true","comparator":"booleanEquals"}}
pub(crate) fn match_describe_key_pairs_0e2929c8dde53894b(
    _result: ::std::result::Result<
        &crate::operation::describe_key_pairs::DescribeKeyPairsOutput,
        &crate::operation::describe_key_pairs::DescribeKeyPairsError,
    >,
) -> bool {
    fn path_traversal<'a>(_output: &'a crate::operation::describe_key_pairs::DescribeKeyPairsOutput) -> ::std::option::Option<bool> {
        let _fld_2 = _output.key_pairs.as_ref()?;
        let _prj_4 = _fld_2
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::KeyPairInfo) -> ::std::option::Option<&::std::string::String> {
                    let _fld_3 = _v.key_name.as_ref();
                    _fld_3
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        let _ret_1 = _prj_4.len() as i64;
        const _LIT_5: &f64 = &0.0;
        let _tmp_7 = *_LIT_5;
        let _tmp_8 = _tmp_7 as i64;
        let _cmp_6 = _ret_1 > _tmp_8;
        ::std::option::Option::Some(_cmp_6)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            let right = true;
            let _cmp_1 = value == right;
            _cmp_1
        })
        .unwrap_or_default()
}

/// Matcher union: {"errorType":"InvalidKeyPair.NotFound"}
pub(crate) fn match_describe_key_pairs_8c790177499d2da21(
    _result: ::std::result::Result<
        &crate::operation::describe_key_pairs::DescribeKeyPairsOutput,
        &crate::operation::describe_key_pairs::DescribeKeyPairsError,
    >,
) -> bool {
    if let ::std::result::Result::Err(err) = _result {
        if let ::std::option::Option::Some(code) = ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(err) {
            return code == "InvalidKeyPair.NotFound";
        }
    }
    false
}

/// Matcher union: {"output":{"path":"NatGateways[].State","expected":"available","comparator":"allStringEquals"}}
pub(crate) fn match_describe_nat_gateways_dfea3cee6f1637ebe(
    _result: ::std::result::Result<
        &crate::operation::describe_nat_gateways::DescribeNatGatewaysOutput,
        &crate::operation::describe_nat_gateways::DescribeNatGatewaysError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_nat_gateways::DescribeNatGatewaysOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::NatGatewayState>> {
        let _fld_1 = _output.nat_gateways.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::NatGateway) -> ::std::option::Option<&crate::types::NatGatewayState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "available";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"NatGateways[].State","expected":"failed","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_nat_gateways_5b87bc23bcc1575a0(
    _result: ::std::result::Result<
        &crate::operation::describe_nat_gateways::DescribeNatGatewaysOutput,
        &crate::operation::describe_nat_gateways::DescribeNatGatewaysError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_nat_gateways::DescribeNatGatewaysOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::NatGatewayState>> {
        let _fld_1 = _output.nat_gateways.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::NatGateway) -> ::std::option::Option<&crate::types::NatGatewayState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "failed";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"NatGateways[].State","expected":"deleting","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_nat_gateways_c2eb75989f812bc12(
    _result: ::std::result::Result<
        &crate::operation::describe_nat_gateways::DescribeNatGatewaysOutput,
        &crate::operation::describe_nat_gateways::DescribeNatGatewaysError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_nat_gateways::DescribeNatGatewaysOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::NatGatewayState>> {
        let _fld_1 = _output.nat_gateways.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::NatGateway) -> ::std::option::Option<&crate::types::NatGatewayState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "deleting";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"NatGateways[].State","expected":"deleted","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_nat_gateways_70354630633fbe807(
    _result: ::std::result::Result<
        &crate::operation::describe_nat_gateways::DescribeNatGatewaysOutput,
        &crate::operation::describe_nat_gateways::DescribeNatGatewaysError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_nat_gateways::DescribeNatGatewaysOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::NatGatewayState>> {
        let _fld_1 = _output.nat_gateways.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::NatGateway) -> ::std::option::Option<&crate::types::NatGatewayState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "deleted";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"errorType":"NatGatewayNotFound"}
pub(crate) fn match_describe_nat_gateways_6513b45eeacbec860(
    _result: ::std::result::Result<
        &crate::operation::describe_nat_gateways::DescribeNatGatewaysOutput,
        &crate::operation::describe_nat_gateways::DescribeNatGatewaysError,
    >,
) -> bool {
    if let ::std::result::Result::Err(err) = _result {
        if let ::std::option::Option::Some(code) = ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(err) {
            return code == "NatGatewayNotFound";
        }
    }
    false
}

/// Matcher union: {"output":{"path":"NatGateways[].State","expected":"deleted","comparator":"allStringEquals"}}
pub(crate) fn match_describe_nat_gateways_943e6d2c961eea64d(
    _result: ::std::result::Result<
        &crate::operation::describe_nat_gateways::DescribeNatGatewaysOutput,
        &crate::operation::describe_nat_gateways::DescribeNatGatewaysError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_nat_gateways::DescribeNatGatewaysOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::NatGatewayState>> {
        let _fld_1 = _output.nat_gateways.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::NatGateway) -> ::std::option::Option<&crate::types::NatGatewayState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "deleted";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"NetworkInterfaces[].Status","expected":"available","comparator":"allStringEquals"}}
pub(crate) fn match_describe_network_interfaces_4dd882351c65a1787(
    _result: ::std::result::Result<
        &crate::operation::describe_network_interfaces::DescribeNetworkInterfacesOutput,
        &crate::operation::describe_network_interfaces::DescribeNetworkInterfacesError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_network_interfaces::DescribeNetworkInterfacesOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::NetworkInterfaceStatus>> {
        let _fld_1 = _output.network_interfaces.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::NetworkInterface) -> ::std::option::Option<&crate::types::NetworkInterfaceStatus> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "available";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"errorType":"InvalidNetworkInterfaceID.NotFound"}
pub(crate) fn match_describe_network_interfaces_aebacc4ff7354056b(
    _result: ::std::result::Result<
        &crate::operation::describe_network_interfaces::DescribeNetworkInterfacesOutput,
        &crate::operation::describe_network_interfaces::DescribeNetworkInterfacesError,
    >,
) -> bool {
    if let ::std::result::Result::Err(err) = _result {
        if let ::std::option::Option::Some(code) = ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(err) {
            return code == "InvalidNetworkInterfaceID.NotFound";
        }
    }
    false
}

/// Matcher union: {"output":{"path":"length(PasswordData) > `0`","expected":"true","comparator":"booleanEquals"}}
pub(crate) fn match_get_password_data_6fefb1345d49c7eeb(
    _result: ::std::result::Result<
        &crate::operation::get_password_data::GetPasswordDataOutput,
        &crate::operation::get_password_data::GetPasswordDataError,
    >,
) -> bool {
    fn path_traversal<'a>(_output: &'a crate::operation::get_password_data::GetPasswordDataOutput) -> ::std::option::Option<bool> {
        let _fld_2 = _output.password_data.as_ref()?;
        let _ret_1 = _fld_2.len() as i64;
        const _LIT_3: &f64 = &0.0;
        let _tmp_5 = *_LIT_3;
        let _tmp_6 = _tmp_5 as i64;
        let _cmp_4 = _ret_1 > _tmp_6;
        ::std::option::Option::Some(_cmp_4)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            let right = true;
            let _cmp_1 = value == right;
            _cmp_1
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"length(SecurityGroups[].GroupId) > `0`","expected":"true","comparator":"booleanEquals"}}
pub(crate) fn match_describe_security_groups_0e75760caea410eed(
    _result: ::std::result::Result<
        &crate::operation::describe_security_groups::DescribeSecurityGroupsOutput,
        &crate::operation::describe_security_groups::DescribeSecurityGroupsError,
    >,
) -> bool {
    fn path_traversal<'a>(_output: &'a crate::operation::describe_security_groups::DescribeSecurityGroupsOutput) -> ::std::option::Option<bool> {
        let _fld_2 = _output.security_groups.as_ref()?;
        let _prj_4 = _fld_2
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::SecurityGroup) -> ::std::option::Option<&::std::string::String> {
                    let _fld_3 = _v.group_id.as_ref();
                    _fld_3
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        let _ret_1 = _prj_4.len() as i64;
        const _LIT_5: &f64 = &0.0;
        let _tmp_7 = *_LIT_5;
        let _tmp_8 = _tmp_7 as i64;
        let _cmp_6 = _ret_1 > _tmp_8;
        ::std::option::Option::Some(_cmp_6)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            let right = true;
            let _cmp_1 = value == right;
            _cmp_1
        })
        .unwrap_or_default()
}

/// Matcher union: {"errorType":"InvalidGroup.NotFound"}
pub(crate) fn match_describe_security_groups_f735c42a19b31c377(
    _result: ::std::result::Result<
        &crate::operation::describe_security_groups::DescribeSecurityGroupsOutput,
        &crate::operation::describe_security_groups::DescribeSecurityGroupsError,
    >,
) -> bool {
    if let ::std::result::Result::Err(err) = _result {
        if let ::std::option::Option::Some(code) = ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(err) {
            return code == "InvalidGroup.NotFound";
        }
    }
    false
}

/// Matcher union: {"output":{"path":"SecurityGroupVpcAssociations[].State","expected":"associated","comparator":"allStringEquals"}}
pub(crate) fn match_describe_security_group_vpc_associations_05a126fd150c44e3d(
    _result: ::std::result::Result<
        &crate::operation::describe_security_group_vpc_associations::DescribeSecurityGroupVpcAssociationsOutput,
        &crate::operation::describe_security_group_vpc_associations::DescribeSecurityGroupVpcAssociationsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_security_group_vpc_associations::DescribeSecurityGroupVpcAssociationsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::SecurityGroupVpcAssociationState>> {
        let _fld_1 = _output.security_group_vpc_associations.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::SecurityGroupVpcAssociation) -> ::std::option::Option<&crate::types::SecurityGroupVpcAssociationState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "associated";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"SecurityGroupVpcAssociations[].State","expected":"associating","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_security_group_vpc_associations_de185f5a68fb264b0(
    _result: ::std::result::Result<
        &crate::operation::describe_security_group_vpc_associations::DescribeSecurityGroupVpcAssociationsOutput,
        &crate::operation::describe_security_group_vpc_associations::DescribeSecurityGroupVpcAssociationsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_security_group_vpc_associations::DescribeSecurityGroupVpcAssociationsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::SecurityGroupVpcAssociationState>> {
        let _fld_1 = _output.security_group_vpc_associations.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::SecurityGroupVpcAssociation) -> ::std::option::Option<&crate::types::SecurityGroupVpcAssociationState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "associating";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"SecurityGroupVpcAssociations[].State","expected":"association-failed","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_security_group_vpc_associations_479ea6c443eaa25e7(
    _result: ::std::result::Result<
        &crate::operation::describe_security_group_vpc_associations::DescribeSecurityGroupVpcAssociationsOutput,
        &crate::operation::describe_security_group_vpc_associations::DescribeSecurityGroupVpcAssociationsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_security_group_vpc_associations::DescribeSecurityGroupVpcAssociationsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::SecurityGroupVpcAssociationState>> {
        let _fld_1 = _output.security_group_vpc_associations.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::SecurityGroupVpcAssociation) -> ::std::option::Option<&crate::types::SecurityGroupVpcAssociationState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "association-failed";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"SecurityGroupVpcAssociations[].State","expected":"disassociated","comparator":"allStringEquals"}}
pub(crate) fn match_describe_security_group_vpc_associations_fbd4d7a53fc8bbc73(
    _result: ::std::result::Result<
        &crate::operation::describe_security_group_vpc_associations::DescribeSecurityGroupVpcAssociationsOutput,
        &crate::operation::describe_security_group_vpc_associations::DescribeSecurityGroupVpcAssociationsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_security_group_vpc_associations::DescribeSecurityGroupVpcAssociationsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::SecurityGroupVpcAssociationState>> {
        let _fld_1 = _output.security_group_vpc_associations.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::SecurityGroupVpcAssociation) -> ::std::option::Option<&crate::types::SecurityGroupVpcAssociationState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "disassociated";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"SecurityGroupVpcAssociations[].State","expected":"disassociating","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_security_group_vpc_associations_1e8485cf2019c71c7(
    _result: ::std::result::Result<
        &crate::operation::describe_security_group_vpc_associations::DescribeSecurityGroupVpcAssociationsOutput,
        &crate::operation::describe_security_group_vpc_associations::DescribeSecurityGroupVpcAssociationsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_security_group_vpc_associations::DescribeSecurityGroupVpcAssociationsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::SecurityGroupVpcAssociationState>> {
        let _fld_1 = _output.security_group_vpc_associations.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::SecurityGroupVpcAssociation) -> ::std::option::Option<&crate::types::SecurityGroupVpcAssociationState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "disassociating";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"SecurityGroupVpcAssociations[].State","expected":"disassociation-failed","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_security_group_vpc_associations_3dceeb9fd052c4973(
    _result: ::std::result::Result<
        &crate::operation::describe_security_group_vpc_associations::DescribeSecurityGroupVpcAssociationsOutput,
        &crate::operation::describe_security_group_vpc_associations::DescribeSecurityGroupVpcAssociationsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_security_group_vpc_associations::DescribeSecurityGroupVpcAssociationsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::SecurityGroupVpcAssociationState>> {
        let _fld_1 = _output.security_group_vpc_associations.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::SecurityGroupVpcAssociation) -> ::std::option::Option<&crate::types::SecurityGroupVpcAssociationState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "disassociation-failed";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"length(SecurityGroupVpcAssociations[]) == `0`","expected":"true","comparator":"booleanEquals"}}
pub(crate) fn match_describe_security_group_vpc_associations_9eb23410274361fd5(
    _result: ::std::result::Result<
        &crate::operation::describe_security_group_vpc_associations::DescribeSecurityGroupVpcAssociationsOutput,
        &crate::operation::describe_security_group_vpc_associations::DescribeSecurityGroupVpcAssociationsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_security_group_vpc_associations::DescribeSecurityGroupVpcAssociationsOutput,
    ) -> ::std::option::Option<bool> {
        let _fld_2 = _output.security_group_vpc_associations.as_ref()?;
        let _ret_1 = _fld_2.len() as i64;
        const _LIT_3: &f64 = &0.0;
        let _tmp_5 = *_LIT_3;
        let _tmp_6 = _tmp_5 as i64;
        let _cmp_4 = _ret_1 == _tmp_6;
        ::std::option::Option::Some(_cmp_4)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            let right = true;
            let _cmp_1 = value == right;
            _cmp_1
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"Snapshots[].State","expected":"completed","comparator":"allStringEquals"}}
pub(crate) fn match_describe_snapshots_a0b4c167203a8805f(
    _result: ::std::result::Result<
        &crate::operation::describe_snapshots::DescribeSnapshotsOutput,
        &crate::operation::describe_snapshots::DescribeSnapshotsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_snapshots::DescribeSnapshotsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::SnapshotState>> {
        let _fld_1 = _output.snapshots.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::Snapshot) -> ::std::option::Option<&crate::types::SnapshotState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "completed";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"Snapshots[].State","expected":"error","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_snapshots_8bfc549023d126af0(
    _result: ::std::result::Result<
        &crate::operation::describe_snapshots::DescribeSnapshotsOutput,
        &crate::operation::describe_snapshots::DescribeSnapshotsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_snapshots::DescribeSnapshotsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::SnapshotState>> {
        let _fld_1 = _output.snapshots.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::Snapshot) -> ::std::option::Option<&crate::types::SnapshotState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "error";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"ImportSnapshotTasks[].SnapshotTaskDetail.Status","expected":"completed","comparator":"allStringEquals"}}
pub(crate) fn match_describe_import_snapshot_tasks_48f4f251081a266e0(
    _result: ::std::result::Result<
        &crate::operation::describe_import_snapshot_tasks::DescribeImportSnapshotTasksOutput,
        &crate::operation::describe_import_snapshot_tasks::DescribeImportSnapshotTasksError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_import_snapshot_tasks::DescribeImportSnapshotTasksOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.import_snapshot_tasks.as_ref()?;
        let _prj_4 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::ImportSnapshotTask) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.snapshot_task_detail.as_ref();
                    let _fld_3 = _fld_2.and_then(|v| v.status.as_ref());
                    _fld_3
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_4)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "completed";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"ImportSnapshotTasks[].SnapshotTaskDetail.Status","expected":"error","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_import_snapshot_tasks_6cd4957a19b889087(
    _result: ::std::result::Result<
        &crate::operation::describe_import_snapshot_tasks::DescribeImportSnapshotTasksOutput,
        &crate::operation::describe_import_snapshot_tasks::DescribeImportSnapshotTasksError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_import_snapshot_tasks::DescribeImportSnapshotTasksOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.import_snapshot_tasks.as_ref()?;
        let _prj_4 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::ImportSnapshotTask) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.snapshot_task_detail.as_ref();
                    let _fld_3 = _fld_2.and_then(|v| v.status.as_ref());
                    _fld_3
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_4)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "error";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"SpotInstanceRequests[].Status.Code","expected":"fulfilled","comparator":"allStringEquals"}}
pub(crate) fn match_describe_spot_instance_requests_c2c04d9a4ae5d9629(
    _result: ::std::result::Result<
        &crate::operation::describe_spot_instance_requests::DescribeSpotInstanceRequestsOutput,
        &crate::operation::describe_spot_instance_requests::DescribeSpotInstanceRequestsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_spot_instance_requests::DescribeSpotInstanceRequestsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.spot_instance_requests.as_ref()?;
        let _prj_4 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::SpotInstanceRequest) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    let _fld_3 = _fld_2.and_then(|v| v.code.as_ref());
                    _fld_3
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_4)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "fulfilled";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"SpotInstanceRequests[].Status.Code","expected":"request-canceled-and-instance-running","comparator":"allStringEquals"}}
pub(crate) fn match_describe_spot_instance_requests_6b6b51b22ad1d72a8(
    _result: ::std::result::Result<
        &crate::operation::describe_spot_instance_requests::DescribeSpotInstanceRequestsOutput,
        &crate::operation::describe_spot_instance_requests::DescribeSpotInstanceRequestsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_spot_instance_requests::DescribeSpotInstanceRequestsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.spot_instance_requests.as_ref()?;
        let _prj_4 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::SpotInstanceRequest) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    let _fld_3 = _fld_2.and_then(|v| v.code.as_ref());
                    _fld_3
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_4)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "request-canceled-and-instance-running";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"SpotInstanceRequests[].Status.Code","expected":"schedule-expired","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_spot_instance_requests_809a1f65cfd031d99(
    _result: ::std::result::Result<
        &crate::operation::describe_spot_instance_requests::DescribeSpotInstanceRequestsOutput,
        &crate::operation::describe_spot_instance_requests::DescribeSpotInstanceRequestsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_spot_instance_requests::DescribeSpotInstanceRequestsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.spot_instance_requests.as_ref()?;
        let _prj_4 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::SpotInstanceRequest) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    let _fld_3 = _fld_2.and_then(|v| v.code.as_ref());
                    _fld_3
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_4)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "schedule-expired";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"SpotInstanceRequests[].Status.Code","expected":"canceled-before-fulfillment","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_spot_instance_requests_9b4f6f29b66bf320d(
    _result: ::std::result::Result<
        &crate::operation::describe_spot_instance_requests::DescribeSpotInstanceRequestsOutput,
        &crate::operation::describe_spot_instance_requests::DescribeSpotInstanceRequestsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_spot_instance_requests::DescribeSpotInstanceRequestsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.spot_instance_requests.as_ref()?;
        let _prj_4 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::SpotInstanceRequest) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    let _fld_3 = _fld_2.and_then(|v| v.code.as_ref());
                    _fld_3
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_4)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "canceled-before-fulfillment";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"SpotInstanceRequests[].Status.Code","expected":"bad-parameters","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_spot_instance_requests_329c85a5dd6416fdd(
    _result: ::std::result::Result<
        &crate::operation::describe_spot_instance_requests::DescribeSpotInstanceRequestsOutput,
        &crate::operation::describe_spot_instance_requests::DescribeSpotInstanceRequestsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_spot_instance_requests::DescribeSpotInstanceRequestsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.spot_instance_requests.as_ref()?;
        let _prj_4 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::SpotInstanceRequest) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    let _fld_3 = _fld_2.and_then(|v| v.code.as_ref());
                    _fld_3
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_4)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "bad-parameters";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"SpotInstanceRequests[].Status.Code","expected":"system-error","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_spot_instance_requests_50622be41ac6539ee(
    _result: ::std::result::Result<
        &crate::operation::describe_spot_instance_requests::DescribeSpotInstanceRequestsOutput,
        &crate::operation::describe_spot_instance_requests::DescribeSpotInstanceRequestsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_spot_instance_requests::DescribeSpotInstanceRequestsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.spot_instance_requests.as_ref()?;
        let _prj_4 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::SpotInstanceRequest) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    let _fld_3 = _fld_2.and_then(|v| v.code.as_ref());
                    _fld_3
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_4)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "system-error";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"errorType":"InvalidSpotInstanceRequestID.NotFound"}
pub(crate) fn match_describe_spot_instance_requests_6685a381c4413cedb(
    _result: ::std::result::Result<
        &crate::operation::describe_spot_instance_requests::DescribeSpotInstanceRequestsOutput,
        &crate::operation::describe_spot_instance_requests::DescribeSpotInstanceRequestsError,
    >,
) -> bool {
    if let ::std::result::Result::Err(err) = _result {
        if let ::std::option::Option::Some(code) = ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(err) {
            return code == "InvalidSpotInstanceRequestID.NotFound";
        }
    }
    false
}

/// Matcher union: {"output":{"path":"StoreImageTaskResults[].StoreTaskState","expected":"Completed","comparator":"allStringEquals"}}
pub(crate) fn match_describe_store_image_tasks_0f3d4ac61f82ed8fe(
    _result: ::std::result::Result<
        &crate::operation::describe_store_image_tasks::DescribeStoreImageTasksOutput,
        &crate::operation::describe_store_image_tasks::DescribeStoreImageTasksError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_store_image_tasks::DescribeStoreImageTasksOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.store_image_task_results.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::StoreImageTaskResult) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.store_task_state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "Completed";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"StoreImageTaskResults[].StoreTaskState","expected":"Failed","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_store_image_tasks_7ae5c4836498ea6aa(
    _result: ::std::result::Result<
        &crate::operation::describe_store_image_tasks::DescribeStoreImageTasksOutput,
        &crate::operation::describe_store_image_tasks::DescribeStoreImageTasksError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_store_image_tasks::DescribeStoreImageTasksOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.store_image_task_results.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::StoreImageTaskResult) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.store_task_state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "Failed";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"StoreImageTaskResults[].StoreTaskState","expected":"InProgress","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_store_image_tasks_1cfe383d503eb8961(
    _result: ::std::result::Result<
        &crate::operation::describe_store_image_tasks::DescribeStoreImageTasksOutput,
        &crate::operation::describe_store_image_tasks::DescribeStoreImageTasksError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_store_image_tasks::DescribeStoreImageTasksOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.store_image_task_results.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::StoreImageTaskResult) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.store_task_state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "InProgress";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"Subnets[].State","expected":"available","comparator":"allStringEquals"}}
pub(crate) fn match_describe_subnets_4dd8b1ce0c2205901(
    _result: ::std::result::Result<
        &crate::operation::describe_subnets::DescribeSubnetsOutput,
        &crate::operation::describe_subnets::DescribeSubnetsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_subnets::DescribeSubnetsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::SubnetState>> {
        let _fld_1 = _output.subnets.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::Subnet) -> ::std::option::Option<&crate::types::SubnetState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "available";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"InstanceStatuses[].SystemStatus.Status","expected":"ok","comparator":"allStringEquals"}}
pub(crate) fn match_describe_instance_status_46ce6aca57818c04b(
    _result: ::std::result::Result<
        &crate::operation::describe_instance_status::DescribeInstanceStatusOutput,
        &crate::operation::describe_instance_status::DescribeInstanceStatusError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_instance_status::DescribeInstanceStatusOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::SummaryStatus>> {
        let _fld_1 = _output.instance_statuses.as_ref()?;
        let _prj_4 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::InstanceStatus) -> ::std::option::Option<&crate::types::SummaryStatus> {
                    let _fld_2 = _v.system_status.as_ref();
                    let _fld_3 = _fld_2.and_then(|v| v.status.as_ref());
                    _fld_3
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_4)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "ok";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"Volumes[].State","expected":"available","comparator":"allStringEquals"}}
pub(crate) fn match_describe_volumes_006c29de4d9c462c7(
    _result: ::std::result::Result<
        &crate::operation::describe_volumes::DescribeVolumesOutput,
        &crate::operation::describe_volumes::DescribeVolumesError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_volumes::DescribeVolumesOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::VolumeState>> {
        let _fld_1 = _output.volumes.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::Volume) -> ::std::option::Option<&crate::types::VolumeState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "available";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"Volumes[].State","expected":"deleted","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_volumes_9cbb763f624bb2e82(
    _result: ::std::result::Result<
        &crate::operation::describe_volumes::DescribeVolumesOutput,
        &crate::operation::describe_volumes::DescribeVolumesError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_volumes::DescribeVolumesOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::VolumeState>> {
        let _fld_1 = _output.volumes.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::Volume) -> ::std::option::Option<&crate::types::VolumeState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "deleted";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"Volumes[].State","expected":"deleted","comparator":"allStringEquals"}}
pub(crate) fn match_describe_volumes_b4b8f2ef2f1069b9d(
    _result: ::std::result::Result<
        &crate::operation::describe_volumes::DescribeVolumesOutput,
        &crate::operation::describe_volumes::DescribeVolumesError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_volumes::DescribeVolumesOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::VolumeState>> {
        let _fld_1 = _output.volumes.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::Volume) -> ::std::option::Option<&crate::types::VolumeState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "deleted";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"errorType":"InvalidVolume.NotFound"}
pub(crate) fn match_describe_volumes_be0fc7d72f426dbae(
    _result: ::std::result::Result<
        &crate::operation::describe_volumes::DescribeVolumesOutput,
        &crate::operation::describe_volumes::DescribeVolumesError,
    >,
) -> bool {
    if let ::std::result::Result::Err(err) = _result {
        if let ::std::option::Option::Some(code) = ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(err) {
            return code == "InvalidVolume.NotFound";
        }
    }
    false
}

/// Matcher union: {"output":{"path":"Volumes[].State","expected":"in-use","comparator":"allStringEquals"}}
pub(crate) fn match_describe_volumes_e6d79e3037e927ea9(
    _result: ::std::result::Result<
        &crate::operation::describe_volumes::DescribeVolumesOutput,
        &crate::operation::describe_volumes::DescribeVolumesError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_volumes::DescribeVolumesOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::VolumeState>> {
        let _fld_1 = _output.volumes.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::Volume) -> ::std::option::Option<&crate::types::VolumeState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "in-use";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"Vpcs[].State","expected":"available","comparator":"allStringEquals"}}
pub(crate) fn match_describe_vpcs_758fa5df2adba3998(
    _result: ::std::result::Result<&crate::operation::describe_vpcs::DescribeVpcsOutput, &crate::operation::describe_vpcs::DescribeVpcsError>,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_vpcs::DescribeVpcsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::VpcState>> {
        let _fld_1 = _output.vpcs.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::Vpc) -> ::std::option::Option<&crate::types::VpcState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "available";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"success":true}
pub(crate) fn match_describe_vpcs_c955e57777ec0d736(
    _result: ::std::result::Result<&crate::operation::describe_vpcs::DescribeVpcsOutput, &crate::operation::describe_vpcs::DescribeVpcsError>,
) -> bool {
    _result.is_ok()
}

/// Matcher union: {"errorType":"InvalidVpcID.NotFound"}
pub(crate) fn match_describe_vpcs_f51411a22e164d79b(
    _result: ::std::result::Result<&crate::operation::describe_vpcs::DescribeVpcsOutput, &crate::operation::describe_vpcs::DescribeVpcsError>,
) -> bool {
    if let ::std::result::Result::Err(err) = _result {
        if let ::std::option::Option::Some(code) = ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(err) {
            return code == "InvalidVpcID.NotFound";
        }
    }
    false
}

/// Matcher union: {"output":{"path":"VpcPeeringConnections[].Status.Code","expected":"deleted","comparator":"allStringEquals"}}
pub(crate) fn match_describe_vpc_peering_connections_38dded2097a8f81f9(
    _result: ::std::result::Result<
        &crate::operation::describe_vpc_peering_connections::DescribeVpcPeeringConnectionsOutput,
        &crate::operation::describe_vpc_peering_connections::DescribeVpcPeeringConnectionsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_vpc_peering_connections::DescribeVpcPeeringConnectionsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::VpcPeeringConnectionStateReasonCode>> {
        let _fld_1 = _output.vpc_peering_connections.as_ref()?;
        let _prj_4 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::VpcPeeringConnection) -> ::std::option::Option<&crate::types::VpcPeeringConnectionStateReasonCode> {
                    let _fld_2 = _v.status.as_ref();
                    let _fld_3 = _fld_2.and_then(|v| v.code.as_ref());
                    _fld_3
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_4)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "deleted";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"errorType":"InvalidVpcPeeringConnectionID.NotFound"}
pub(crate) fn match_describe_vpc_peering_connections_e0cb68a203dc3e8d0(
    _result: ::std::result::Result<
        &crate::operation::describe_vpc_peering_connections::DescribeVpcPeeringConnectionsOutput,
        &crate::operation::describe_vpc_peering_connections::DescribeVpcPeeringConnectionsError,
    >,
) -> bool {
    if let ::std::result::Result::Err(err) = _result {
        if let ::std::option::Option::Some(code) = ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(err) {
            return code == "InvalidVpcPeeringConnectionID.NotFound";
        }
    }
    false
}

/// Matcher union: {"success":true}
pub(crate) fn match_describe_vpc_peering_connections_c955e57777ec0d736(
    _result: ::std::result::Result<
        &crate::operation::describe_vpc_peering_connections::DescribeVpcPeeringConnectionsOutput,
        &crate::operation::describe_vpc_peering_connections::DescribeVpcPeeringConnectionsError,
    >,
) -> bool {
    _result.is_ok()
}

/// Matcher union: {"output":{"path":"VpnConnections[].State","expected":"available","comparator":"allStringEquals"}}
pub(crate) fn match_describe_vpn_connections_70b193b3621ebab21(
    _result: ::std::result::Result<
        &crate::operation::describe_vpn_connections::DescribeVpnConnectionsOutput,
        &crate::operation::describe_vpn_connections::DescribeVpnConnectionsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_vpn_connections::DescribeVpnConnectionsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::VpnState>> {
        let _fld_1 = _output.vpn_connections.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::VpnConnection) -> ::std::option::Option<&crate::types::VpnState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "available";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"VpnConnections[].State","expected":"deleting","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_vpn_connections_ca4f43c6c5dfc3212(
    _result: ::std::result::Result<
        &crate::operation::describe_vpn_connections::DescribeVpnConnectionsOutput,
        &crate::operation::describe_vpn_connections::DescribeVpnConnectionsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_vpn_connections::DescribeVpnConnectionsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::VpnState>> {
        let _fld_1 = _output.vpn_connections.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::VpnConnection) -> ::std::option::Option<&crate::types::VpnState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "deleting";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"VpnConnections[].State","expected":"deleted","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_vpn_connections_59d6f494234bab17e(
    _result: ::std::result::Result<
        &crate::operation::describe_vpn_connections::DescribeVpnConnectionsOutput,
        &crate::operation::describe_vpn_connections::DescribeVpnConnectionsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_vpn_connections::DescribeVpnConnectionsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::VpnState>> {
        let _fld_1 = _output.vpn_connections.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::VpnConnection) -> ::std::option::Option<&crate::types::VpnState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "deleted";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"VpnConnections[].State","expected":"deleted","comparator":"allStringEquals"}}
pub(crate) fn match_describe_vpn_connections_3fdf8e45e4e684e38(
    _result: ::std::result::Result<
        &crate::operation::describe_vpn_connections::DescribeVpnConnectionsOutput,
        &crate::operation::describe_vpn_connections::DescribeVpnConnectionsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_vpn_connections::DescribeVpnConnectionsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::VpnState>> {
        let _fld_1 = _output.vpn_connections.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::VpnConnection) -> ::std::option::Option<&crate::types::VpnState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "deleted";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"VpnConnections[].State","expected":"pending","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_vpn_connections_5becee76bf19ae9e0(
    _result: ::std::result::Result<
        &crate::operation::describe_vpn_connections::DescribeVpnConnectionsOutput,
        &crate::operation::describe_vpn_connections::DescribeVpnConnectionsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_vpn_connections::DescribeVpnConnectionsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a crate::types::VpnState>> {
        let _fld_1 = _output.vpn_connections.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::VpnConnection) -> ::std::option::Option<&crate::types::VpnState> {
                    let _fld_2 = _v.state.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "pending";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}
