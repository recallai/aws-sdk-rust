// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Describes a route server and its configuration.</p>
/// <p>Amazon VPC Route Server simplifies routing for traffic between workloads that are deployed within a VPC and its internet gateways. With this feature, VPC Route Server dynamically updates VPC and internet gateway route tables with your preferred IPv4 or IPv6 routes to achieve routing fault tolerance for those workloads. This enables you to automatically reroute traffic within a VPC, which increases the manageability of VPC routing and interoperability with third-party workloads.</p>
/// <p>Route server supports the follow route table types:</p>
/// <ul>
/// <li>
/// <p>VPC route tables not associated with subnets</p></li>
/// <li>
/// <p>Subnet route tables</p></li>
/// <li>
/// <p>Internet gateway route tables</p></li>
/// </ul>
/// <p>Route server does not support route tables associated with virtual private gateways. To propagate routes into a transit gateway route table, use <a href="https://docs.aws.amazon.com/vpc/latest/tgw/tgw-connect.html">Transit Gateway Connect</a>.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct RouteServer {
    /// <p>The unique identifier of the route server.</p>
    pub route_server_id: ::std::option::Option<::std::string::String>,
    /// <p>The Border Gateway Protocol (BGP) Autonomous System Number (ASN) for the appliance. Valid values are from 1 to 4294967295. We recommend using a private ASN in the 64512–65534 (16-bit ASN) or 4200000000–4294967294 (32-bit ASN) range.</p>
    pub amazon_side_asn: ::std::option::Option<i64>,
    /// <p>The current state of the route server.</p>
    pub state: ::std::option::Option<crate::types::RouteServerState>,
    /// <p>Any tags assigned to the route server.</p>
    pub tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
    /// <p>The current state of route persistence for the route server.</p>
    pub persist_routes_state: ::std::option::Option<crate::types::RouteServerPersistRoutesState>,
    /// <p>The number of minutes a route server will wait after BGP is re-established to unpersist the routes in the FIB and RIB. Value must be in the range of 1-5. The default value is 1. Only valid if <code>persistRoutesState</code> is 'enabled'.</p>
    /// <p>If you set the duration to 1 minute, then when your network appliance re-establishes BGP with route server, it has 1 minute to relearn it's adjacent network and advertise those routes to route server before route server resumes normal functionality. In most cases, 1 minute is probably sufficient. If, however, you have concerns that your BGP network may not be capable of fully re-establishing and re-learning everything in 1 minute, you can increase the duration up to 5 minutes.</p>
    pub persist_routes_duration: ::std::option::Option<i64>,
    /// <p>Indicates whether SNS notifications are enabled for the route server. Enabling SNS notifications persists BGP status changes to an SNS topic provisioned by Amazon Web Services.</p>
    pub sns_notifications_enabled: ::std::option::Option<bool>,
    /// <p>The ARN of the SNS topic where notifications are published.</p>
    pub sns_topic_arn: ::std::option::Option<::std::string::String>,
}
impl RouteServer {
    /// <p>The unique identifier of the route server.</p>
    pub fn route_server_id(&self) -> ::std::option::Option<&str> {
        self.route_server_id.as_deref()
    }
    /// <p>The Border Gateway Protocol (BGP) Autonomous System Number (ASN) for the appliance. Valid values are from 1 to 4294967295. We recommend using a private ASN in the 64512–65534 (16-bit ASN) or 4200000000–4294967294 (32-bit ASN) range.</p>
    pub fn amazon_side_asn(&self) -> ::std::option::Option<i64> {
        self.amazon_side_asn
    }
    /// <p>The current state of the route server.</p>
    pub fn state(&self) -> ::std::option::Option<&crate::types::RouteServerState> {
        self.state.as_ref()
    }
    /// <p>Any tags assigned to the route server.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.tags.is_none()`.
    pub fn tags(&self) -> &[crate::types::Tag] {
        self.tags.as_deref().unwrap_or_default()
    }
    /// <p>The current state of route persistence for the route server.</p>
    pub fn persist_routes_state(&self) -> ::std::option::Option<&crate::types::RouteServerPersistRoutesState> {
        self.persist_routes_state.as_ref()
    }
    /// <p>The number of minutes a route server will wait after BGP is re-established to unpersist the routes in the FIB and RIB. Value must be in the range of 1-5. The default value is 1. Only valid if <code>persistRoutesState</code> is 'enabled'.</p>
    /// <p>If you set the duration to 1 minute, then when your network appliance re-establishes BGP with route server, it has 1 minute to relearn it's adjacent network and advertise those routes to route server before route server resumes normal functionality. In most cases, 1 minute is probably sufficient. If, however, you have concerns that your BGP network may not be capable of fully re-establishing and re-learning everything in 1 minute, you can increase the duration up to 5 minutes.</p>
    pub fn persist_routes_duration(&self) -> ::std::option::Option<i64> {
        self.persist_routes_duration
    }
    /// <p>Indicates whether SNS notifications are enabled for the route server. Enabling SNS notifications persists BGP status changes to an SNS topic provisioned by Amazon Web Services.</p>
    pub fn sns_notifications_enabled(&self) -> ::std::option::Option<bool> {
        self.sns_notifications_enabled
    }
    /// <p>The ARN of the SNS topic where notifications are published.</p>
    pub fn sns_topic_arn(&self) -> ::std::option::Option<&str> {
        self.sns_topic_arn.as_deref()
    }
}
impl RouteServer {
    /// Creates a new builder-style object to manufacture [`RouteServer`](crate::types::RouteServer).
    pub fn builder() -> crate::types::builders::RouteServerBuilder {
        crate::types::builders::RouteServerBuilder::default()
    }
}

/// A builder for [`RouteServer`](crate::types::RouteServer).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct RouteServerBuilder {
    pub(crate) route_server_id: ::std::option::Option<::std::string::String>,
    pub(crate) amazon_side_asn: ::std::option::Option<i64>,
    pub(crate) state: ::std::option::Option<crate::types::RouteServerState>,
    pub(crate) tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
    pub(crate) persist_routes_state: ::std::option::Option<crate::types::RouteServerPersistRoutesState>,
    pub(crate) persist_routes_duration: ::std::option::Option<i64>,
    pub(crate) sns_notifications_enabled: ::std::option::Option<bool>,
    pub(crate) sns_topic_arn: ::std::option::Option<::std::string::String>,
}
impl RouteServerBuilder {
    /// <p>The unique identifier of the route server.</p>
    pub fn route_server_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.route_server_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique identifier of the route server.</p>
    pub fn set_route_server_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.route_server_id = input;
        self
    }
    /// <p>The unique identifier of the route server.</p>
    pub fn get_route_server_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.route_server_id
    }
    /// <p>The Border Gateway Protocol (BGP) Autonomous System Number (ASN) for the appliance. Valid values are from 1 to 4294967295. We recommend using a private ASN in the 64512–65534 (16-bit ASN) or 4200000000–4294967294 (32-bit ASN) range.</p>
    pub fn amazon_side_asn(mut self, input: i64) -> Self {
        self.amazon_side_asn = ::std::option::Option::Some(input);
        self
    }
    /// <p>The Border Gateway Protocol (BGP) Autonomous System Number (ASN) for the appliance. Valid values are from 1 to 4294967295. We recommend using a private ASN in the 64512–65534 (16-bit ASN) or 4200000000–4294967294 (32-bit ASN) range.</p>
    pub fn set_amazon_side_asn(mut self, input: ::std::option::Option<i64>) -> Self {
        self.amazon_side_asn = input;
        self
    }
    /// <p>The Border Gateway Protocol (BGP) Autonomous System Number (ASN) for the appliance. Valid values are from 1 to 4294967295. We recommend using a private ASN in the 64512–65534 (16-bit ASN) or 4200000000–4294967294 (32-bit ASN) range.</p>
    pub fn get_amazon_side_asn(&self) -> &::std::option::Option<i64> {
        &self.amazon_side_asn
    }
    /// <p>The current state of the route server.</p>
    pub fn state(mut self, input: crate::types::RouteServerState) -> Self {
        self.state = ::std::option::Option::Some(input);
        self
    }
    /// <p>The current state of the route server.</p>
    pub fn set_state(mut self, input: ::std::option::Option<crate::types::RouteServerState>) -> Self {
        self.state = input;
        self
    }
    /// <p>The current state of the route server.</p>
    pub fn get_state(&self) -> &::std::option::Option<crate::types::RouteServerState> {
        &self.state
    }
    /// Appends an item to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>Any tags assigned to the route server.</p>
    pub fn tags(mut self, input: crate::types::Tag) -> Self {
        let mut v = self.tags.unwrap_or_default();
        v.push(input);
        self.tags = ::std::option::Option::Some(v);
        self
    }
    /// <p>Any tags assigned to the route server.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>Any tags assigned to the route server.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Tag>> {
        &self.tags
    }
    /// <p>The current state of route persistence for the route server.</p>
    pub fn persist_routes_state(mut self, input: crate::types::RouteServerPersistRoutesState) -> Self {
        self.persist_routes_state = ::std::option::Option::Some(input);
        self
    }
    /// <p>The current state of route persistence for the route server.</p>
    pub fn set_persist_routes_state(mut self, input: ::std::option::Option<crate::types::RouteServerPersistRoutesState>) -> Self {
        self.persist_routes_state = input;
        self
    }
    /// <p>The current state of route persistence for the route server.</p>
    pub fn get_persist_routes_state(&self) -> &::std::option::Option<crate::types::RouteServerPersistRoutesState> {
        &self.persist_routes_state
    }
    /// <p>The number of minutes a route server will wait after BGP is re-established to unpersist the routes in the FIB and RIB. Value must be in the range of 1-5. The default value is 1. Only valid if <code>persistRoutesState</code> is 'enabled'.</p>
    /// <p>If you set the duration to 1 minute, then when your network appliance re-establishes BGP with route server, it has 1 minute to relearn it's adjacent network and advertise those routes to route server before route server resumes normal functionality. In most cases, 1 minute is probably sufficient. If, however, you have concerns that your BGP network may not be capable of fully re-establishing and re-learning everything in 1 minute, you can increase the duration up to 5 minutes.</p>
    pub fn persist_routes_duration(mut self, input: i64) -> Self {
        self.persist_routes_duration = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of minutes a route server will wait after BGP is re-established to unpersist the routes in the FIB and RIB. Value must be in the range of 1-5. The default value is 1. Only valid if <code>persistRoutesState</code> is 'enabled'.</p>
    /// <p>If you set the duration to 1 minute, then when your network appliance re-establishes BGP with route server, it has 1 minute to relearn it's adjacent network and advertise those routes to route server before route server resumes normal functionality. In most cases, 1 minute is probably sufficient. If, however, you have concerns that your BGP network may not be capable of fully re-establishing and re-learning everything in 1 minute, you can increase the duration up to 5 minutes.</p>
    pub fn set_persist_routes_duration(mut self, input: ::std::option::Option<i64>) -> Self {
        self.persist_routes_duration = input;
        self
    }
    /// <p>The number of minutes a route server will wait after BGP is re-established to unpersist the routes in the FIB and RIB. Value must be in the range of 1-5. The default value is 1. Only valid if <code>persistRoutesState</code> is 'enabled'.</p>
    /// <p>If you set the duration to 1 minute, then when your network appliance re-establishes BGP with route server, it has 1 minute to relearn it's adjacent network and advertise those routes to route server before route server resumes normal functionality. In most cases, 1 minute is probably sufficient. If, however, you have concerns that your BGP network may not be capable of fully re-establishing and re-learning everything in 1 minute, you can increase the duration up to 5 minutes.</p>
    pub fn get_persist_routes_duration(&self) -> &::std::option::Option<i64> {
        &self.persist_routes_duration
    }
    /// <p>Indicates whether SNS notifications are enabled for the route server. Enabling SNS notifications persists BGP status changes to an SNS topic provisioned by Amazon Web Services.</p>
    pub fn sns_notifications_enabled(mut self, input: bool) -> Self {
        self.sns_notifications_enabled = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates whether SNS notifications are enabled for the route server. Enabling SNS notifications persists BGP status changes to an SNS topic provisioned by Amazon Web Services.</p>
    pub fn set_sns_notifications_enabled(mut self, input: ::std::option::Option<bool>) -> Self {
        self.sns_notifications_enabled = input;
        self
    }
    /// <p>Indicates whether SNS notifications are enabled for the route server. Enabling SNS notifications persists BGP status changes to an SNS topic provisioned by Amazon Web Services.</p>
    pub fn get_sns_notifications_enabled(&self) -> &::std::option::Option<bool> {
        &self.sns_notifications_enabled
    }
    /// <p>The ARN of the SNS topic where notifications are published.</p>
    pub fn sns_topic_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.sns_topic_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ARN of the SNS topic where notifications are published.</p>
    pub fn set_sns_topic_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.sns_topic_arn = input;
        self
    }
    /// <p>The ARN of the SNS topic where notifications are published.</p>
    pub fn get_sns_topic_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.sns_topic_arn
    }
    /// Consumes the builder and constructs a [`RouteServer`](crate::types::RouteServer).
    pub fn build(self) -> crate::types::RouteServer {
        crate::types::RouteServer {
            route_server_id: self.route_server_id,
            amazon_side_asn: self.amazon_side_asn,
            state: self.state,
            tags: self.tags,
            persist_routes_state: self.persist_routes_state,
            persist_routes_duration: self.persist_routes_duration,
            sns_notifications_enabled: self.sns_notifications_enabled,
            sns_topic_arn: self.sns_topic_arn,
        }
    }
}
